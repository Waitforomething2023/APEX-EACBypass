# APEX-EACBypass  
# 用法：  
 编译出来重命名为"EasyAntiCheat_launcher.exe"替换到游戏目录下，用橘子平台启动游戏  
# 关于心跳
写个空的dll命名为"EasyAntiCheat_x64.dll"替换到游戏目录下用你自己的方式加载到游戏里  
如果以后加强了怎么办？通用找法：挂调试器上去，游戏大厅挂机，等调试器断下，应该是断在检测到EAC未运行那个画面，执行到用户代码，发现是"binkawin64.dll"这个模块的线程，
然后，看是程序哪里起的这个线程，一层层回溯上去。
取巧的办法：柿子挑软的捏，那些同时使用UE和EAC的游戏，大部分裤子都被扒干净了，找到他们的SDK，其中引用EAC SDK的部分，看一看EAC的SDK整体的结构是怎么样的，大概有什么函数，dump下进程来看看反汇编的样子，然后可以在APEX里面找找看。
不过这个游戏是起源改，不久后难逃被被扒光的命运，毕竟起源引擎"约等于"开源引擎。
取巧的办法2：游戏没加壳，拿起他的EAC key就跑啊。
# RWE Bypass
EAC用ObRegisterCallbacks注册了4-5个回调，直接恢复游戏秒结束，所以恢复不可行(而且起了几个线程一直在检测和恢复)，头部ret也不行。它做了什么：降权  
举个例子：比如你要打开"r5apex.exe"这个进程，"PROCESS_ALL_ACCESS"，肯定被降权，这个时候你先别管他去掉了哪几个权限，传到你的驱动里面，遍历句柄表找到这个句柄把"GrantedAccess"改成"0x1FFFFF".  
现在EAC还没有和BE一样定时清空句柄表，先这么用着吧，如果他开始定时清空句柄表了，那“完全的R3读写”就要另辟巧径了.  
# 应用层  
首先对部分关键sdk函数进行下断，如下图所示：  
![bp Cerberus_GameRoundStart](/pics/bp.png)  
![游戏对EACR3模块的引用](/pics/ref.png)  
![引用处的部分代码1](/pics/1.png)    
![引用处的部分代码2](/pics/2.png)  
![引用处的部分代码3](/pics/3.png)  
实际上，关键函数并没有断下，即游戏开始时没有通知eac模块，猜测保护并没有运行。  
2019.2.26补充  
检测都在IGO64.DLL这个模块里，趁着没加壳请保存好版本，留特征备用。   
# 内核层  
图标：obj钩子砍了以后就有了
读写：挂回调拿句柄写权限
一系列调试检测，比如查DebugPort的，这些内核线程，枚举出来以后通通暂停，退出游戏前恢复。  
